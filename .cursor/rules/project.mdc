---
description: Project conventions and coding standards for web-whiteboard
globs: ["**/*.{js,jsx,ts,tsx,css}"]
alwaysApply: true
---

# Web Whiteboard - Project Rules

## Project Overview

A lightweight, infinite canvas whiteboard app built with React 19 and Vite. Features include:
- Infinite pan/zoom canvas with grid
- Multiple brush tools: pen, marker, highlighter, eraser
- Touch support with pinch-to-zoom
- Image paste/drop support
- Light/dark theme (follows system preference)
- Keyboard shortcuts (Cmd/Ctrl+Z undo, Cmd/Ctrl+Shift+Z redo)

## Tech Stack

- **Framework**: React 19.1+ with Vite 7
- **Language**: JavaScript (JSX) - no TypeScript in components
- **Styling**: CSS Modules for components, global CSS variables in `src/styles/`
- **Testing**: Vitest + React Testing Library
- **Linting**: ESLint

## File Structure (Module-Based Architecture)

We use **Module-Based Architecture** where top-level folders represent business domains, not technology types.

```
src/
├── styles/              # Global styles (variables, reset, typography, utilities)
├── components/          # SHARED, DUMB UI only (knows nothing about modules)
│   ├── AppShell/        # Consistent chrome across all modules
│   ├── ModeSwitcher/    # Tab/button group to switch modules
│   ├── HelpPanel/       # Configurable help panel (receives content from modules)
│   ├── FooterBadge/     # "Made with love" footer
│   ├── IconButton/      # Reusable toolbar button
│   └── ThemeToggle/     # Light/dark mode toggle button
├── hooks/               # APP-WIDE generic hooks only
│   └── useTheme.js      # Theme state with system preference detection
├── utils/               # APP-WIDE generic helpers only
│   └── math.js          # Generic math functions
├── modules/             # THE CORE BUSINESS LOGIC
│   └── Whiteboard/      # Everything for the drawing module
│       ├── components/  # Components ONLY used by Whiteboard
│       │   ├── Canvas/
│       │   └── BrushPalette/
│       ├── hooks/       # Domain-specific hooks
│       │   ├── useCanvasSetup.js
│       │   ├── useCanvasView.js
│       │   ├── useStrokeManager.js
│       │   ├── useKeyboardShortcuts.js
│       │   ├── useWheelZoom.js
│       │   ├── usePinchZoom.js
│       │   └── useImagePaste.js
│       ├── utils/       # Canvas-specific utilities
│       │   └── canvas.js
│       ├── constants/   # Tool definitions, colors, sizes
│       │   ├── tools.js
│       │   └── colors.js
│       ├── config.js    # Module configuration (helpItems, etc)
│       └── index.js     # Public API - only export what App needs
├── App.jsx
├── App.css
└── index.jsx
```

### Architecture Rules

**1. Module Encapsulation**
- All whiteboard logic lives in `modules/Whiteboard/`
- Each module has its own hooks/, components/, utils/, constants/
- `index.js` exports only the public API

**2. Shared Components (`src/components/`)**
- Only "dumb" UI components (Button, Modal, Tooltip)
- Know nothing about canvas or drawing logic
- Reusable across any module

**3. Global Hooks (`src/hooks/`)**
- Only hooks that could work in any project
- If a hook mentions "Canvas", "Stroke", "Zoom" → it belongs in the module

**4. Import Rules**
```js
// ✓ GOOD: Module imports shared components
import { IconButton } from '@/components/IconButton';

// ✓ GOOD: Module imports its own hooks (relative)
import { useStrokeManager } from './hooks/useStrokeManager';

// ✓ GOOD: App imports module's public API
import { Whiteboard } from '@/modules/Whiteboard';

// ✗ BAD: App imports module internals
import { BrushPalette } from '@/modules/Whiteboard/components/BrushPalette';
```

## Code Modularity & Anti-Bloat Rules

**CRITICAL**: Keep files small, focused, and maintainable. Extract logic proactively.

### File Size Limits

**Hard limits** - Refactor when exceeded:
- **Components**: 300 lines max
- **Hooks**: 150 lines max  
- **Utility files**: 200 lines max

**Soft limits** - Consider refactoring:
- **Components**: 200+ lines
- **Hooks**: 100+ lines
- **Any file**: If it handles multiple concerns

### When to Extract

**Extract custom hooks when:**
- Component has 3+ useState calls for related state
- Complex logic blocks (20+ lines) that could be reused
- Side effects that could be isolated (data fetching, subscriptions)
- State management for a specific feature (text editing, image handling)

**Extract components when:**
- JSX block is 50+ lines
- Repeated UI patterns
- Complex conditional rendering
- Feature-specific toolbars, panels, or controls

**Extract utilities when:**
- Pure functions used in multiple places
- Complex calculations or transformations
- Helper functions that don't need component context

### Refactoring Examples

**❌ BAD: Bloated component**
```jsx
function Canvas() {
  // 50 lines of state
  const [textEdit, setTextEdit] = useState(null);
  const [showFontMenu, setShowFontMenu] = useState(false);
  const [customColor, setCustomColor] = useState('#000');
  // ... 47 more state declarations
  
  // 100 lines of callbacks
  const handleTextEdit = () => { /* 30 lines */ };
  const handleColorChange = () => { /* 25 lines */ };
  // ... 10 more handlers
  
  // 400 lines of JSX
  return (
    <div>
      {/* 200 lines of toolbar */}
      {/* 200 lines of canvas */}
    </div>
  );
}
```

**✅ GOOD: Extracted and modular**
```jsx
function Canvas() {
  const textEditor = useTextEditor({ tool, onToolChange, strokesRef });
  const drawingState = useDrawing();
  
  return (
    <div>
      {textEditor.isActive && (
        <TextToolbar {...textEditor} />
      )}
      <CanvasBoard {...drawingState} />
    </div>
  );
}

// In hooks/useTextEditor.js (150 lines)
function useTextEditor({ tool, onToolChange, strokesRef }) {
  // All text editing state and logic
}

// In components/TextToolbar/TextToolbar.jsx (200 lines)
function TextToolbar({ textEdit, setTextEdit, ... }) {
  // Just the toolbar UI
}
```

### Extraction Guidelines

**Create hooks for:**
- State management (e.g., `useTextEditor`, `useDrawing`)
- Complex interactions (e.g., `usePinchZoom`, `useImagePaste`)
- Side effects (e.g., `useKeyboardShortcuts`, `useAutoSave`)
- Computed values (e.g., `useCanvasView`, `useCoordinates`)

**Create components for:**
- Toolbars, panels, controls (e.g., `TextToolbar`, `ColorPicker`)
- Repeated UI patterns (e.g., `MenuButton`, `Dropdown`)
- Feature-specific UI (e.g., `BrushPalette`, `HelpPanel`)
- Any JSX block 50+ lines

**Keep together:**
- Closely coupled logic (extraction would add complexity)
- Single-use, simple logic (< 20 lines)
- Configuration objects and constants

### Naming Conventions

**Hooks**: `use[Feature][Action]`
- `useTextEditor` - manages text editing
- `useImagePaste` - handles image pasting
- `useCanvasView` - manages pan/zoom view

**Components**: `[Feature][Type]`
- `TextToolbar` - toolbar for text
- `ColorPicker` - picker for colors
- `BrushPalette` - palette for brushes

**Files**: Match export name
- `useTextEditor.js` exports `useTextEditor`
- `TextToolbar.jsx` exports `TextToolbar`
- Always use barrel exports (`index.js`)

### Review Checklist

Before committing, ask:
- [ ] Is any file over 300 lines?
- [ ] Does any component have 5+ useState calls?
- [ ] Is there a 50+ line JSX block that could be a component?
- [ ] Is there complex logic (20+ lines) that could be a hook?
- [ ] Are there repeated patterns that could be extracted?

If YES to any → Refactor before committing.

## AppShell Pattern

The app uses an **AppShell** component that provides consistent chrome across all modules.

### What AppShell Provides (Shared)
- ModeSwitcher (tabs to switch between modules)
- HelpPanel (configurable per module)
- ThemeToggle
- FooterBadge

### What Modules Provide (Module-Specific)
- Main content (canvas, workspace, etc.)
- Module-specific toolbar/palette
- Configuration (`config.js` with helpItems, etc.)

### Module Configuration

Each module exports a `config.js`:

```js
// modules/Whiteboard/config.js
export const moduleConfig = {
  id: 'whiteboard',
  label: 'Whiteboard',
  icon: '✏️',
  helpItems: [
    'Draw: Left mouse / 1‑finger drag',
    'Pan: Hold Space and drag',
    // ...
  ],
};
```

### Adding a New Module

1. Create folder: `src/modules/NewModule/`
2. Add `config.js` with moduleConfig
3. Add main component + module-specific palette
4. Export from `index.js`:
   ```js
   export { default as NewModule } from './NewModule';
   export { moduleConfig } from './config';
   ```
5. Register in `App.jsx`:
   ```js
   const MODULE_CONFIGS = {
     whiteboard: whiteboardConfig,
     newmodule: newModuleConfig,
   };
   ```
6. Uncomment mode in `ModeSwitcher.jsx`

## CSS Conventions

### Global Variables (src/styles/variables.css)

Always use CSS custom properties for consistency:

```css
/* Spacing */
var(--spacing-xs)   /* 4px */
var(--spacing-sm)   /* 6px */
var(--spacing-md)   /* 8px */
var(--spacing-lg)   /* 10px */
var(--spacing-xl)   /* 12px */

/* Border Radius */
var(--radius-sm)    /* 8px */
var(--radius-md)    /* 10px */
var(--radius-pill)  /* 999px */

/* Z-Index Scale */
var(--z-canvas)     /* 1 */
var(--z-palette)    /* 16 */
var(--z-toaster)    /* 19 */
var(--z-toggle)     /* 20 */
var(--z-badge)      /* 21 */
var(--z-popover)    /* 100 */

/* Theme Colors */
var(--bg)           /* Background */
var(--text)         /* Text color */
var(--panel-bg)     /* Panel background */
var(--panel-border) /* Panel border */
var(--accent)       /* Accent color */
```

### CSS Module Naming

- Use camelCase for class names: `.paletteBtn`, `.toasterContent`
- Keep selectors flat, avoid deep nesting
- Mobile-first approach with `@media (hover: hover) and (pointer: fine)` for desktop

### Minimal Comments

- Avoid excessive comment headers in CSS
- Only add comments for non-obvious code
- No section dividers like `/* ========== */`

## React Conventions

### Component Structure

```jsx
import React from 'react'
import styles from './ComponentName.module.css'

export default function ComponentName({ prop1, prop2 }) {
  // hooks first
  const [state, setState] = React.useState(initial)
  
  // derived values
  const computed = React.useMemo(() => ..., [deps])
  
  // callbacks
  const handleClick = React.useCallback(() => ..., [deps])
  
  // effects last
  React.useEffect(() => ..., [deps])
  
  return (
    <div className={styles.container}>
      ...
    </div>
  )
}
```

### Hooks Usage

- Prefer `React.useState`, `React.useEffect` over destructured imports
- Use refs for mutable values that don't trigger re-renders
- Extract complex logic into custom hooks in `src/hooks/`

### Barrel Exports

Each component folder has an `index.js`:

```js
export { default } from './ComponentName.jsx'
```

## Canvas/Drawing Specific

### Coordinate Systems

- **Screen space**: Pixel coordinates from mouse/touch events
- **World space**: Infinite canvas coordinates (after pan/zoom transform)
- Use `screenToWorld(sx, sy)` to convert between them

### Stroke Data Structure

```js
{
  mode: 'theme' | 'custom' | 'image',
  points: [{ x, y, p }],  // p = pressure
  size: number,
  color: string | undefined,
  alpha: number,
  erase: boolean,
  cap: 'round',
  join: 'round'
}
```

### View State

```js
{
  panX: number,   // horizontal offset
  panY: number,   // vertical offset  
  scale: number   // zoom level (0.05 to 20)
}
```

## Testing

### Test Framework
- **Vitest** for test runner
- **React Testing Library** for component tests
- **jsdom** environment

### Test File Naming
- Place tests next to source files: `useCanvasView.js` → `useCanvasView.test.js`
- Component tests: `ComponentName.test.jsx`
- Utility tests: `utilName.test.js`

### Commands
```bash
npm test          # Watch mode
npm test -- --run # Run once (CI)
```

### Test Structure
```js
import { describe, it, expect, vi } from 'vitest';
import { renderHook, act } from '@testing-library/react';

describe('hookName', () => {
  it('describes expected behavior', () => {
    const { result } = renderHook(() => useMyHook());
    
    act(() => {
      result.current.doSomething();
    });
    
    expect(result.current.value).toBe(expected);
  });
});
```

### Testing Guidelines
- Test behavior, not implementation
- Use `renderHook` for custom hooks
- Use `render` + `screen` for components
- Mock canvas APIs in `vitest.setup.js`
- Avoid testing internal state directly

### Current Test Coverage

**Module Tests (src/modules/Whiteboard/)**
- `hooks/useCanvasSetup.test.js` - DPR scaling, resize
- `hooks/useCanvasView.test.js` - pan/zoom, coordinate conversion
- `hooks/useStrokeManager.test.js` - undo/redo history
- `utils/canvas.test.js` - clamp, getThemeColors
- `constants/tools.test.js` - tool kinds, stroke size, alpha
- `constants/colors.test.js` - color palette, theme swatches
- `constants/sizes.test.js` - brush sizes, swatch height
- `config.test.js` - module configuration structure

**Component Tests (src/components/)**
- `HelpPanel/HelpPanel.test.jsx` - toggle, items rendering, theme button
- `AppShell/AppShell.test.jsx` - children, chrome components
- `FooterBadge/FooterBadge.test.jsx` - rendering, link attributes
- `ModeSwitcher/ModeSwitcher.test.jsx` - hidden when single mode

**Global Tests (src/)**
- `hooks/useTheme.test.js` - theme toggle, system preference
- `App.test.jsx` - help panel interaction

## Git Workflow

- Keep commits focused and atomic
- Run `npm run lint` before committing
- Run `npm run typecheck` to verify types
